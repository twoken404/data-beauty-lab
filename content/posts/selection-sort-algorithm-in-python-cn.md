---
title: "选择排序：从混乱到有序的艺术"
date: 2025-12-25
slug: "selection-sort-algorithm-in-python-cn"
categories: ["算法", "Python编程"]
tags: ["排序算法", "选择排序", "Python", "数据结构", "算法入门"]
draft: false
---

### 什么是选择排序？

选择排序是一种简单直观的比较排序算法。它的工作原理非常简单：**不断地从未排序的部分中选出最小（或最大）的元素，放到已排序部分的末尾**。你可以把它想象成在排队时，每次都从队伍里找出个子最矮的人，让他站到排好序的队伍后面。

### 算法核心思想

选择排序将数组（或列表）分为两部分：
1.  **已排序部分**：位于序列的左端，初始时为空。
2.  **未排序部分**：位于序列的右端，初始时为整个序列。

在每一次迭代中，算法都会**扫描整个未排序部分**，找到其中最小（以升序为例）的元素，然后将这个最小元素与未排序部分的第一个元素进行交换。这样，未排序部分的第一个元素就加入了已排序部分的末尾。

### 算法步骤详解

让我们通过一个具体的例子来拆解这个过程。假设我们要对数组 `[64, 25, 12, 22, 11]` 进行升序排序。

**初始状态**：
未排序：[64, 25, 12, 22, 11]
已排序：[]

**第一轮**：
*   在未排序部分 `[64, 25, 12, 22, 11]` 中找出最小值 `11`。
*   将最小值 `11` 与未排序部分的第一个元素 `64` 交换。
*   结果：`[11, 25, 12, 22, 64]`
*   状态更新：
    已排序：[11]
    未排序：[25, 12, 22, 64]

**第二轮**：
*   在未排序部分 `[25, 12, 22, 64]` 中找出最小值 `12`。
*   将 `12` 与 `25` 交换。
*   结果：`[11, 12, 25, 22, 64]`
*   状态更新：
    已排序：[11, 12]
    未排序：[25, 22, 64]

**第三轮**：
*   在未排序部分 `[25, 22, 64]` 中找出最小值 `22`。
*   将 `22` 与 `25` 交换。
*   结果：`[11, 12, 22, 25, 64]`
*   状态更新：
    已排序：[11, 12, 22]
    未排序：[25, 64]

**第四轮**：
*   在未排序部分 `[25, 64]` 中找出最小值 `25`。它已经是第一个元素，无需交换。
*   结果：`[11, 12, 22, 25, 64]`
*   状态更新：
    已排序：[11, 12, 22, 25]
    未排序：[64]

此时，未排序部分只剩一个元素，整个数组排序完成。

### Python代码实现

让我们看看如何在Python中实现选择排序。

```python
def selection_sort(arr):
    """
    对列表进行原地选择排序（升序）。
    
    参数:
        arr: 待排序的列表
        
    返回:
        None (列表被原地修改)
    """
    n = len(arr)
    
    # 遍历所有数组元素
    for i in range(n):
        # 假设当前索引 i 处的元素是最小的
        min_idx = i
        
        # 在 i+1 到 n-1 的范围内寻找更小的元素
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j  # 更新最小元素的索引
                
        # 将找到的最小元素与第 i 个位置的元素交换
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

# 示例：对数字列表排序
numbers = [64, 25, 12, 22, 11]
print("排序前:", numbers)
selection_sort(numbers)
print("排序后:", numbers)

# 示例：对字符串列表排序（按字母顺序）
words = ["apple", "banana", "cherry", "date", "blueberry"]
print("\n排序前:", words)
selection_sort(words)  # 字符串比较基于Unicode码点
print("排序后:", words)

# 示例：对元组列表排序（按第一个元素）
items = [(2, 'b'), (1, 'a'), (4, 'd'), (3, 'c')]
print("\n排序前:", items)
selection_sort(items)  # 比较元组的第一个元素
print("排序后:", items)
```

### 与其他排序算法的比较

选择排序以其简单性著称，但在性能上并非最优。在选择排序和之间，有一个关键区别。

{{< bilibili BV1uL4y187Dz >}}

**选择排序 vs. 冒泡排序**：
*   **交换次数**：选择排序每轮最多只交换一次元素，而冒泡排序可能进行多次相邻交换。这使得选择排序在数据写入成本较高时（如写入闪存）更具优势。
*   **稳定性**：标准的选择排序是**不稳定**的。考虑列表 `[(4, 'a'), (2, 'b'), (4, 'c'), (1, 'd')]`。当按第一个元素排序时，两个值为4的元组相对顺序可能被打乱。冒泡排序通常是稳定的。

**时间复杂度分析**：
*   **最优、最差、平均情况**：无论输入数据如何，选择排序都需要进行 `n(n-1)/2` 次比较，因此其时间复杂度始终为 **O(n²)**。
*   **空间复杂度**：由于是原地排序，空间复杂度为 **O(1)**。

### 算法优化思路

尽管基本选择排序的效率是固定的O(n²)，我们仍可以思考一些优化的可能性：

1.  **同时寻找最小和最大值**：在每轮遍历中，我们可以同时找到未排序部分的最小值和最大值，分别放到已排序部分的开头和末尾，这样理论上可以将遍历次数减半。
2.  **稳定性优化**：通过采用**插入**而非**交换**的方式，可以实现稳定的选择排序，但这会牺牲空间复杂度。

### 适用场景

选择排序在以下场景可能适用：
*   **数据量非常小**，简单性比效率更重要。
*   **交换操作代价高昂**，而比较操作代价低廉。
*   **内存空间极其有限**，需要一个严格的原地排序算法。
*   **教学目的**，帮助初学者理解排序算法的基本思想。